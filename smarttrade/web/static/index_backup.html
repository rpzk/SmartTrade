<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SmartTrade</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; 
      background: #0a0e27; 
      color: #e2e8f0; 
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    #toolbar {
      background: rgba(15, 23, 42, 0.95);
      backdrop-filter: blur(10px);
      padding: 0.75rem 1.5rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      z-index: 100;
      flex-shrink: 0;
    }
    
    select, input {
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(30, 41, 59, 0.8);
      color: #e2e8f0;
      font: inherit;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    select:hover, input:hover {
      border-color: rgba(99, 102, 241, 0.5);
      background: rgba(30, 41, 59, 1);
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: #6366f1;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    
    input[type="number"] {
      width: 80px;
    }
    
    #chart-container {
      flex: 1;
      padding: 1.5rem;
      position: relative;
      overflow: hidden;
    }
    
    #chart {
      width: 100%;
      height: 100%;
    }
    
    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #10b981;
      box-shadow: 0 0 8px #10b981;
      animation: pulse 2s ease-in-out infinite;
      margin-left: auto;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .divider {
      width: 1px;
      height: 24px;
      background: rgba(255, 255, 255, 0.1);
    }
    
    .help-text {
      color: #64748b;
      font-size: 0.75rem;
      margin-left: auto;
      margin-right: 1rem;
      user-select: none;
    }
    
    button {
      padding: 0.5rem 0.75rem;
      background: rgba(99, 102, 241, 0.2);
      border: 1px solid rgba(99, 102, 241, 0.4);
      color: #a5b4fc;
      cursor: pointer;
      border-radius: 6px;
      font-size: 0.85rem;
      transition: all 0.2s ease;
    }
    
    button:hover {
      background: rgba(99, 102, 241, 0.3) !important;
      border-color: rgba(99, 102, 241, 0.6) !important;
      color: #c7d2fe !important;
      transform: translateY(-1px);
    }
    
    button:active {
      transform: translateY(0);
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <input id="search-symbol" type="text" placeholder="Buscar s√≠mbolo..." style="width: 150px;" />
    
    <select id="symbol">
      <option value="">Carregando...</option>
    </select>
    
    <select id="interval">
      <option>1m</option>
      <option>5m</option>
      <option selected>15m</option>
      <option>1h</option>
      <option>4h</option>
      <option>1d</option>
    </select>
    
    <input id="limit" type="number" min="100" max="1500" value="1000" />
    
    <div class="divider"></div>
    
    <button id="reset-zoom">üîç Reset</button>
    
    <span class="help-text">üí° Arraste para mover ‚Ä¢ Scroll para zoom ‚Ä¢ Duplo clique para reset</span>
    
    <div class="status-indicator" id="status"></div>
  </div>
  
  <div id="chart-container">
    <div id="chart"></div>
  </div>

  <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
  <script>
    const $ = (id) => document.getElementById(id);
    let ws;
    let chart;
    let candleSeries;
    let bidLine;
    let askLine;
    let availableSymbols = [];
    let isLoadingHistory = false;
    let oldestTimestamp = null;
    let candleData = []; // Cache local dos dados

    function createChart() {
      const container = $('chart');
      const symbol = $('symbol').value;
      
      console.log('Creating Lightweight Chart...');
      
      chart = LightweightCharts.createChart(container, {
        layout: {
          background: { color: '#0a0e27' },
          textColor: '#94a3b8',
        },
        grid: {
          vertLines: { color: 'rgba(255, 255, 255, 0.05)' },
          horzLines: { color: 'rgba(255, 255, 255, 0.05)' },
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Normal,
        },
        rightPriceScale: {
          borderColor: 'rgba(255, 255, 255, 0.1)',
        },
        timeScale: {
          borderColor: 'rgba(255, 255, 255, 0.1)',
          timeVisible: true,
          secondsVisible: false,
          minBarSpacing: 3, // Espa√ßamento m√≠nimo entre barras (limita zoom out significativamente)
          rightOffset: 12, // Margem √† direita
          fixLeftEdge: false,
          fixRightEdge: false,
          lockVisibleTimeRangeOnResize: true,
        },
        handleScroll: {
          mouseWheel: true,
          pressedMouseMove: true,
          horzTouchDrag: true,
          vertTouchDrag: true,
        },
        handleScale: {
          axisPressedMouseMove: true,
          mouseWheel: true,
          pinch: true,
        },
      });

      // Candlestick series
      candleSeries = chart.addCandlestickSeries({
        upColor: '#10b981',
        downColor: '#ef4444',
        borderVisible: false,
        wickUpColor: '#10b981',
        wickDownColor: '#ef4444',
      });

      // Bid line (green)
      bidLine = chart.addLineSeries({
        color: 'rgba(16, 185, 129, 0.8)',
        lineWidth: 2,
        lineStyle: LightweightCharts.LineStyle.Dashed,
        crosshairMarkerVisible: false,
        lastValueVisible: true,
        priceLineVisible: false,
      });

      // Ask line (red)
      askLine = chart.addLineSeries({
        color: 'rgba(239, 68, 68, 0.8)',
        lineWidth: 2,
        lineStyle: LightweightCharts.LineStyle.Dashed,
        crosshairMarkerVisible: false,
        lastValueVisible: true,
        priceLineVisible: false,
      });

      // Auto-resize
      new ResizeObserver(() => {
        chart.applyOptions({ 
          width: container.clientWidth,
          height: container.clientHeight 
        });
      }).observe(container);

      // Monitor visible range for lazy loading and zoom limits
      chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
        checkAndLoadHistory();
        enforceZoomLimits();
      });

      console.log('Chart created successfully');
    }

    function enforceZoomLimits() {
      if (!chart || candleData.length === 0) return;
      
      const visibleLogicalRange = chart.timeScale().getVisibleLogicalRange();
      if (!visibleLogicalRange) return;
      
      const barsVisible = visibleLogicalRange.to - visibleLogicalRange.from;
      const totalBars = candleData.length;
      
      // Limites: m√≠nimo 10 candles, m√°ximo 120% dos dados
      const minBars = Math.min(10, totalBars);
      const maxBars = totalBars * 1.2;
      
      let needsAdjustment = false;
      let newFrom = visibleLogicalRange.from;
      let newTo = visibleLogicalRange.to;
      
      // Se zoom out excessivo
      if (barsVisible > maxBars) {
        const center = (visibleLogicalRange.from + visibleLogicalRange.to) / 2;
        newFrom = center - maxBars / 2;
        newTo = center + maxBars / 2;
        needsAdjustment = true;
      }
      
      // Se zoom in excessivo
      if (barsVisible < minBars) {
        const center = (visibleLogicalRange.from + visibleLogicalRange.to) / 2;
        newFrom = center - minBars / 2;
        newTo = center + minBars / 2;
        needsAdjustment = true;
      }
      
      // Garante que n√£o sai dos limites dos dados
      if (newFrom < -5) newFrom = -5;
      if (newTo > totalBars + 5) newTo = totalBars + 5;
      
      if (needsAdjustment) {
        chart.timeScale().setVisibleLogicalRange({
          from: newFrom,
          to: newTo
        });
      }
    }

    async function checkAndLoadHistory() {
      if (!candleSeries || isLoadingHistory || !oldestTimestamp) return;
      
      const visibleLogicalRange = chart.timeScale().getVisibleLogicalRange();
      if (!visibleLogicalRange) return;

      // Se estamos vendo os primeiros 20% dos dados carregados, busca mais
      const threshold = candleData.length * 0.2;
      if (visibleLogicalRange.from < threshold) {
        console.log('üì• Near edge (viewing first 20%), loading more history...');
        await loadMoreHistory();
      }
    }

    async function loadMoreHistory() {
      if (isLoadingHistory) return;
      isLoadingHistory = true;
      
      const symbol = $("symbol").value;
      const interval = $("interval").value;
      const limit = 500; // Carrega 500 candles adicionais por vez
      
      try {
        console.log(`Loading more history before ${new Date(oldestTimestamp).toISOString()}`);
        
        const response = await fetch(`/api/swap/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${limit}&endTime=${oldestTimestamp - 1}`);
        if (!response.ok) throw new Error(`${response.status}`);
        
        const klines = await response.json();
        if (klines.length === 0) {
          console.log('No more historical data available');
          return;
        }
        
        console.log(`‚úÖ Loaded ${klines.length} additional candles`);
        
        // Convert and prepend data
        const newCandles = klines.map(c => ({
          time: Math.floor(c.time / 1000), // Lightweight Charts uses seconds
          open: +c.open,
          high: +c.high,
          low: +c.low,
          close: +c.close,
        }));
        
        candleData = [...newCandles, ...candleData];
        candleSeries.setData(candleData);
        oldestTimestamp = klines[0].time;
        
        console.log(`Total candles now: ${candleData.length}`);
      } catch (e) {
        console.error('Error loading historical data:', e);
      } finally {
        isLoadingHistory = false;
      }
    }

    function upsertCandle(time, open, high, low, close) {
      const candleTime = Math.floor(time / 1000);
      const candle = {
        time: candleTime,
        open: +open,
        high: +high,
        low: +low,
        close: +close,
      };
      
      candleSeries.update(candle);
      
      // Update cache
      const existingIndex = candleData.findIndex(c => c.time === candleTime);
      if (existingIndex >= 0) {
        candleData[existingIndex] = candle;
      } else {
        candleData.push(candle);
        candleData.sort((a, b) => a.time - b.time);
      }
    }

    async function loadAvailableSymbols() {
      try {
        const response = await fetch('/api/swap/contracts');
        if (!response.ok) throw new Error(`${response.status}`);
        const contracts = await response.json();
        
        availableSymbols = contracts.map(c => c.symbol).sort();
        console.log(`Loaded ${availableSymbols.length} symbols`);
        
        populateSymbolSelect('');
      } catch (e) {
        console.error('Error loading symbols:', e);
        $('symbol').innerHTML = '<option value="BTC-USDT">BTC-USDT</option>';
      }
    }

    function populateSymbolSelect(filterText) {
      const filter = filterText.toLowerCase();
      const filtered = availableSymbols.filter(s => s.toLowerCase().includes(filter));
      
      const principais = ['BTC-USDT', 'ETH-USDT', 'BNB-USDT', 'SOL-USDT'];
      const defi = filtered.filter(s => ['UNI', 'AAVE', 'LINK', 'SUSHI', 'CRV', 'COMP'].some(t => s.includes(t)));
      const commodities = filtered.filter(s => ['XAUT', 'PAXG'].some(t => s.includes(t)));
      const outros = filtered.filter(s => !principais.includes(s) && !defi.includes(s) && !commodities.includes(s));
      
      let html = '';
      
      if (principais.some(s => s.toLowerCase().includes(filter))) {
        html += '<optgroup label="Principais">';
        principais.filter(s => s.toLowerCase().includes(filter)).forEach(s => {
          html += `<option value="${s}">${s}</option>`;
        });
        html += '</optgroup>';
      }
      
      if (defi.length > 0) {
        html += '<optgroup label="DeFi">';
        defi.forEach(s => html += `<option value="${s}">${s}</option>`);
        html += '</optgroup>';
      }
      
      if (commodities.length > 0) {
        html += '<optgroup label="Commodities">';
        commodities.forEach(s => html += `<option value="${s}">${s}</option>`);
        html += '</optgroup>';
      }
      
      if (outros.length > 0) {
        const outrosLimited = outros.slice(0, 100);
        html += '<optgroup label="Outros">';
        outrosLimited.forEach(s => html += `<option value="${s}">${s}</option>`);
        if (outros.length > 100) {
          html += `<option disabled>... e mais ${outros.length - 100}</option>`;
        }
        html += '</optgroup>';
      }
      
      $('symbol').innerHTML = html || '<option value="">Nenhum s√≠mbolo encontrado</option>';
    }

    let searchTimeout;
    $('search-symbol').addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        populateSymbolSelect(e.target.value);
      }, 300);
    });

    async function loadKlines() {
      const symbol = $("symbol").value;
      const interval = $("interval").value;
      const limit = $("limit").value;

      console.log(`Loading klines: ${symbol} ${interval} (limit: ${limit})`);

      try {
        const response = await fetch(`/api/swap/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}&limit=${encodeURIComponent(limit)}`);
        if (!response.ok) throw new Error(`${response.status}`);
        
        const klines = await response.json();
        console.log(`Received ${klines.length} klines`);
        
        if (!chart) {
          console.log('Creating chart...');
          createChart();
        }
        
        // Convert to Lightweight Charts format (uses seconds, not milliseconds)
        candleData = klines.map(c => ({
          time: Math.floor(c.time / 1000),
          open: +c.open,
          high: +c.high,
          low: +c.low,
          close: +c.close,
        }));
        
        candleSeries.setData(candleData);
        
        if (candleData.length > 0) {
          oldestTimestamp = klines[0].time;
        }
        
        chart.timeScale().fitContent();
        
        console.log(`Chart updated with ${candleData.length} candles`);
      } catch (e) {
        console.error('Error loading klines:', e);
      }
    }

    function connectWebSocket() {
      if (ws) { 
        try { ws.close(); } catch (_) {} 
      }
      
      const symbol = $("symbol").value;
      const interval = $("interval").value;
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      const url = `${proto}://${location.host}/ws/swap/klines?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(interval)}`;
      
      ws = new WebSocket(url);
      
      ws.onopen = () => {
        $('status').style.background = '#10b981';
        $('status').style.boxShadow = '0 0 8px #10b981';
      };
      
      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          
          if (msg.type === 'snapshot') {
            console.log(`WS Snapshot received: ${msg.data?.length || 0} candles`);
            if (!chart) createChart();
            
            const rows = msg.data || [];
            candleData = rows.map(c => ({
              time: Math.floor(c.time / 1000),
              open: +c.open,
              high: +c.high,
              low: +c.low,
              close: +c.close,
            }));
            candleSeries.setData(candleData);
            chart.timeScale().fitContent();
            
          } else if (msg.type === 'kline') {
            const c = msg.data;
            upsertCandle(c.time, c.open, c.high, c.low, c.close);
          }
        } catch (e) {
          console.error('WebSocket message error:', e);
        }
      };
      
      ws.onclose = () => {
        $('status').style.background = '#ef4444';
        $('status').style.boxShadow = '0 0 8px #ef4444';
        setTimeout(connectWebSocket, 2000);
      };
      
      ws.onerror = () => {
        $('status').style.background = '#f59e0b';
        $('status').style.boxShadow = '0 0 8px #f59e0b';
        try { ws.close(); } catch (_) {}
      };
    }

    let bidAskInterval;
    
    async function updateBidAsk() {
      if (!chart || !bidLine || !askLine || candleData.length === 0) return;
      
      const symbol = $("symbol").value;
      try {
        const response = await fetch(`/api/swap/ticker?symbol=${encodeURIComponent(symbol)}`);
        if (!response.ok) return;
        
        const ticker = await response.json();
        const bidPrice = parseFloat(ticker.bidPrice);
        const askPrice = parseFloat(ticker.askPrice);
        
        if (!bidPrice || !askPrice) return;
        
        // Use actual data time range from our cache
        const firstTime = candleData[0].time;
        const lastTime = candleData[candleData.length - 1].time;
        
        // Update bid line using actual data time range
        bidLine.setData([
          { time: firstTime, value: bidPrice },
          { time: lastTime, value: bidPrice }
        ]);
        
        // Update ask line using actual data time range
        askLine.setData([
          { time: firstTime, value: askPrice },
          { time: lastTime, value: askPrice }
        ]);
      } catch (e) {
        console.error('Error updating bid/ask:', e);
      }
    }

    function handleChange() {
      loadKlines();
      connectWebSocket();
      
      if (bidAskInterval) clearInterval(bidAskInterval);
      updateBidAsk();
      bidAskInterval = setInterval(updateBidAsk, 1000);
    }

    function resetZoom() {
      if (!chart) return;
      chart.timeScale().fitContent();
    }

    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM ready');
      
      $('symbol').addEventListener('change', handleChange);
      $('interval').addEventListener('change', handleChange);
      $('limit').addEventListener('change', handleChange);
      $('reset-zoom').addEventListener('click', resetZoom);
      
      loadAvailableSymbols().then(() => {
        $('symbol').value = 'BTC-USDT';
        handleChange();
      });
    });
  </script>
</body>
</html>
